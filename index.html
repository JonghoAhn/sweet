<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>학생 자리 배치</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            color: #334155;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 2rem;
        }
        .container {
            background-color: #ffffff;
            border-radius: 1.5rem; /* Increased border radius for more rounded corners */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 2.5rem;
            width: 100%;
            max-width: 1200px;
            display: flex;
            flex-wrap: wrap;
            gap: 2rem;
            position: relative;
            flex-direction: column;
        }
        .header-panel {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #e2e8f0;
        }
        .header-buttons {
            display: flex;
            gap: 0.75rem;
        }
        .main-content-panels {
            display: flex;
            flex-wrap: wrap;
            gap: 2rem;
            width: 100%;
        }
        .control-panel, .settings-panel {
            flex: 1;
            min-width: 300px;
            padding: 1.5rem;
            background-color: #f8fafc;
            border-radius: 1rem;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.06);
        }
        .classroom-layout-container {
            flex: 2;
            min-width: 400px;
            padding: 1.5rem;
            background-color: #f8fafc;
            border-radius: 1rem;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.06);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative; /* Added for overlay positioning */
        }
        .classroom-layout-header {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 1.5rem;
        }
        .classroom-layout {
            display: grid;
            gap: 0.75rem;
            padding: 1rem;
            background-color: #e2e8f0;
            border-radius: 0.75rem;
            box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.1);
            width: fit-content;
            max-width: 100%;
            overflow-x: auto;
        }
        .desk {
            width: 80px;
            height: 80px;
            border-radius: 0.5rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-weight: 600;
            color: white;
            text-align: center;
            transition: background-color 0.3s ease, transform 0.1s ease, border 0.2s ease, box-shadow 0.2s ease, opacity 0.3s ease;
            cursor: default;
            user-select: none;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            font-size: 0.9rem;
            padding: 5px;
            word-break: keep-all;
            position: relative; /* For the delete button */
        }
        .desk .desk-number {
            font-size: 0.75rem;
            opacity: 0.7;
            position: absolute;
            top: 5px;
            left: 5px;
            color: rgba(255,255,255,0.8);
        }
        .desk .student-name {
            font-size: 1rem;
            font-weight: 700;
            margin-top: 10px;
        }
        .desk .student-gender {
            font-size: 0.75rem;
            font-weight: 500;
            opacity: 0.8;
        }

        /* Desk type colors */
        .desk-type-random { background-color: #facc15; } /* Yellow */
        .desk-type-male { background-color: #3b82f6; }   /* Blue */
        .desk-type-female { background-color: #ec4899; } /* Pink */
        
        /* Specific colors when occupied based on student gender */
        .desk.occupied.student-gender-male { background-color: #2563eb; } /* Darker blue for male */
        .desk.occupied.student-gender-female { background-color: #db2777; } /* Darker pink for female */
        .desk.occupied.student-gender-unknown { background-color: #d97706; } /* Darker yellow/orange for unknown */

        /* Desk inactive (deleted) state */
        .desk.inactive {
            background-color: #e2e8f0; /* Light grey */
            color: #94a3b8; /* Darker grey text */
            opacity: 0.7;
            cursor: not-allowed;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.06); /* Inset shadow */
        }
        .desk.inactive .student-name,
        .desk.inactive .student-gender {
            display: none; /* Hide student name/gender when inactive */
        }

        /* Highlight for preference setting (click desk first) */
        .desk.preference-focused {
            border: 2px solid #22c55e; /* Green border for preference focus */
            box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.5); /* Green glow */
        }
        
        .desk.dragging {
            opacity: 0.5;
            border: 2px dashed #3b82f6;
            cursor: grabbing;
        }
        .desk.drag-over {
            transform: scale(1.05);
            box-shadow: 0 0 0 4px #4f46e5;
        }
        .desk:hover:not(.dragging):not(.inactive) { /* Hover effect only if not dragging and not inactive */
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
        }
        
        /* Delete button on desk */
        .desk-delete-btn {
            position: absolute;
            top: -8px; /* Slightly outside for visibility */
            right: -8px; /* Slightly outside for visibility */
            background-color: #ef4444; /* Red */
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.8rem;
            font-weight: bold;
            cursor: pointer;
            border: 1px solid #b91c1c;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: transform 0.1s ease, background-color 0.1s ease;
            opacity: 0; /* Hidden by default */
            visibility: hidden; /* Hidden by default */
            z-index: 10; /* Above student name */
        }
        .desk:hover .desk-delete-btn {
            opacity: 1; /* Visible on desk hover */
            visibility: visible;
            transform: scale(1.1);
        }
        .desk-delete-btn:hover {
            background-color: #dc2626; /* Darker red on hover */
            transform: scale(1.1) rotate(15deg);
        }
        .desk-delete-btn:active {
            transform: scale(1.0);
        }

        /* Input & Button Styles (mostly Tailwind defaults, adapted for rounded and shadows) */
        input[type="number"],
        textarea,
        input[type="text"] {
            padding: 0.75rem;
            border-radius: 0.5rem;
            border: 1px solid #cbd5e1;
            width: 100%;
            background-color: #fefefe;
            font-size: 1rem;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        input[type="number"]:focus,
        textarea:focus,
        input[type="text"]:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.25);
        }
        button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            background-image: linear-gradient(to right, #6366f1, #3b82f6);
            color: white;
            border: none;
        }
        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
            background-image: linear-gradient(to right, #4f46e5, #2563eb);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .btn-secondary {
            background-image: linear-gradient(to right, #cbd5e1, #94a3b8);
        }
        .btn-secondary:hover {
            background-image: linear-gradient(to right, #a0aec0, #718096);
        }
        .btn-add-student {
            background-image: linear-gradient(to right, #22c55e, #16a34a); /* Green gradient */
        }
        .btn-add-student:hover {
            background-image: linear-gradient(to right, #16a34a, #15803d);
        }
        .btn-delete-student {
            background-image: linear-gradient(to right, #ef4444, #dc2626); /* Red gradient */
        }
        .btn-delete-student:hover {
            background-image: linear-gradient(to right, #dc2626, #b91c1c);
        }
        .btn-reset {
            background-image: linear-gradient(to right, #f97316, #ea580c); /* Orange gradient */
        }
        .btn-reset:hover {
            background-image: linear-gradient(to right, #fb923c, #f97316);
        }

        .student-list-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            background-color: #f0f4f8;
            border-radius: 0.5rem;
        }
        .student-list-item input[type="text"] {
            flex-grow: 1;
            margin-right: 0.5rem;
        }
        .student-list-item .gender-checkbox-group {
            display: flex;
            gap: 0.5rem;
            margin-right: 0.5rem;
        }
        .student-list-item .gender-checkbox-group label {
            display: flex;
            align-items: center;
            cursor: pointer;
            user-select: none;
            color: #334155;
            font-size: 0.875rem;
        }
        .student-list-item .gender-checkbox-group input[type="checkbox"] {
            width: auto; /* Override full width */
            margin-right: 0.25rem;
            width: 1rem; /* Adjust checkbox size */
            height: 1rem;
        }

        /* Message Box & Tutorial Box & Data Management Box */
        .message-box, .tutorial-message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            display: none;
            flex-direction: column;
            gap: 1rem;
            align-items: center;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
        }
        .message-box p, .tutorial-message-box p {
            font-size: 1.125rem;
            text-align: center;
        }
        .message-box button, .tutorial-message-box button {
            padding: 0.6rem 1.2rem;
            font-size: 1rem;
        }
        .tutorial-message-box h3 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #334155;
        }
        .tutorial-message-box ol {
            list-style: decimal;
            padding-left: 1.5rem;
            margin-bottom: 1rem;
            text-align: left;
        }
        .tutorial-message-box li {
            margin-bottom: 0.5rem;
            font-size: 1rem;
            color: #475569;
        }
        .tutorial-message-box li strong {
            color: #1e293b;
        }

        /* Snapshot History Panel specific styles */
        .snapshot-history-panel {
            flex: 1; /* Take up similar space as settings-panel */
            min-width: 300px;
            padding: 1.5rem;
            background-color: #f8fafc;
            border-radius: 1rem;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.06);
            /* Hidden by default, toggled by button */
        }
        .snapshot-history-panel .input-group {
            width: 100%;
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-bottom: 1rem;
        }
        .snapshot-history-panel .input-group input {
            flex-grow: 1;
        }
        .snapshot-history-panel .saved-snapshots-list {
            width: 100%;
            border: 1px solid #cbd5e1;
            border-radius: 0.5rem;
            max-height: 250px; /* Adjusted height for panel view */
            overflow-y: auto;
            margin-bottom: 1rem;
        }
        .snapshot-history-panel .saved-snapshot-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            border-bottom: 1px solid #e2e8f0;
            font-size: 0.9rem;
            color: #475569;
        }
        .snapshot-history-panel .saved-snapshot-item:last-child {
            border-bottom: none;
        }
        .snapshot-history-panel .snapshot-details {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            flex-grow: 1;
            margin-right: 0.5rem;
        }
        .snapshot-history-panel .snapshot-name {
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 0.2rem;
        }
        .snapshot-history-panel .snapshot-timestamp {
            font-size: 0.75rem;
            color: #64748b;
        }
        .snapshot-history-panel .snapshot-actions {
            display: flex;
            gap: 0.5rem;
        }
        .snapshot-history-panel .snapshot-actions button {
            padding: 0.4rem 0.8rem;
            font-size: 0.8rem;
            box-shadow: none;
        }
        .snapshot-history-panel .snapshot-actions .btn-load {
            background-image: linear-gradient(to right, #3b82f6, #2563eb);
        }
        .snapshot-history-panel .snapshot-actions .btn-delete {
            background-image: linear-gradient(to right, #ef4444, #dc2626);
        }


        /* Drag ghost element style */
        .drag-ghost {
            position: fixed;
            background-color: rgba(59, 130, 246, 0.8);
            border-radius: 0.5rem;
            width: 80px;
            height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-weight: 600;
            color: white;
            text-align: center;
            pointer-events: none;
            z-index: 999;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.25);
            transition: none;
        }
        .drag-ghost .desk-number { /* Hide number on ghost */
            display: none;
        }
        /* Hidden utility class */
        .hidden {
            display: none !important;
        }
        .settings-icon-button {
            background: none;
            border: none;
            padding: 0.5rem;
            cursor: pointer;
            transition: transform 0.2s ease, opacity 0.2s ease;
            box-shadow: none;
        }
        .settings-icon-button:hover {
            transform: rotate(30deg);
            opacity: 0.8;
            box-shadow: none;
            background-image: none;
        }
         .settings-icon-button:active {
            transform: rotate(60deg);
            opacity: 0.6;
            box-shadow: none;
        }
        .settings-icon {
            width: 24px;
            height: 24px;
            fill: #64748b;
        }

        /* New styles for tooltips */
        .icon-button-container {
            position: relative;
            display: flex; /* To allow centering and relative positioning of tooltip */
            justify-content: center;
            align-items: center;
        }

        .icon-button-tooltip {
            position: absolute;
            top: 100%; /* Position below the button */
            margin-top: 5px; /* Spacing from the button */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(49, 57, 72, 0.9); /* Dark background */
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem; /* Smaller text */
            white-space: nowrap; /* Prevent text wrapping */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            pointer-events: none; /* Crucial: allows clicking through the tooltip to the button */
            z-index: 500; /* Ensure it's above other elements but below modals */
        }

        .icon-button-container:hover .icon-button-tooltip {
            opacity: 1;
            visibility: visible;
        }

        /* Desk Options Overlay */
        .desk-options-overlay {
            position: absolute;
            background-color: #fff;
            border: 1px solid #cbd5e1;
            border-radius: 0.75rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 0.75rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 100;
            min-width: 120px;
            text-align: center;
        }
        .desk-options-overlay button {
            width: 100%;
            padding: 0.5rem;
            font-size: 0.9rem;
            border-radius: 0.4rem;
            box-shadow: none;
            background-image: none;
            background-color: #f0f4f8;
            color: #334155;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }
        .desk-options-overlay button:hover {
            background-color: #e2e8f0;
            transform: none;
            box-shadow: none;
        }
        .desk-options-overlay button:active {
            transform: translateY(0);
        }
        .desk-options-overlay .btn-delete-option {
            background-color: #ef4444;
            color: white;
        }
        .desk-options-overlay .btn-delete-option:hover {
            background-color: #dc2626;
        }
        .desk-options-overlay .btn-male-option {
            background-color: #60a5fa;
            color: white;
        }
        .desk-options-overlay .btn-male-option:hover {
            background-color: #3b82f6;
        }
        .desk-options-overlay .btn-female-option {
            background-color: #f472b6;
            color: white;
        }
        .desk-options-overlay .btn-female-option:hover {
            background-color: #ec4899;
        }
        .desk-options-overlay .btn-random-option {
            background-color: #fbbf24;
            color: white;
        }
        .desk-options-overlay .btn-random-option:hover {
            background-color: #facc15;
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="header-panel">
            <h1 class="text-3xl font-bold text-gray-900">학생 자리 배치 도구</h1>
            <div class="header-buttons">
                <button onclick="showTutorialMessageBox()" class="btn-secondary">튜토리얼</button>
                <!-- Toggle button for Avoid Settings Panel -->
                <div class="icon-button-container">
                    <button onclick="toggleAvoidSettings()" class="settings-icon-button">
                        <svg class="settings-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                            <path fill-rule="evenodd" d="M11.078 2.29c.47-.1.97-.1 1.442 0l.21.04a1 1 0 01.62.62l.04.21c.174.836.852 1.514 1.688 1.688l.21.04a1 1 0 01.62.62l.04.21c.1.47.1 1.012 0 1.482l-.04.21a1 1 0 01-.62.62l-.21.04c-.836.174-1.514.852-1.688-1.688l-.04.21a1 1 0 01-.62.62l-.21.04c-.47.1-.97.1-1.442 0l-.21-.04a1 1 0 01-.62-.62l-.04-.21c-.174-.836-.852-1.514-1.688-1.688l-.21-.04a1 1 0 01-.62-.62l-.04-.21c-.1-.47-.1-1.012 0-1.482l.04-.21a1 1 0 01.62-.62l.21-.04c.836-.174 1.514-.852 1.688-1.688l.04-.21a1 1 0 01.62-.62l.21-.04zM12 15a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd" />
                        </svg>
                    </button>
                    <span class="icon-button-tooltip">설정</span>
                </div>
                <!-- Toggle button for Snapshot History Panel -->
                <div class="icon-button-container">
                    <button onclick="toggleSnapshotHistoryPanel()" class="settings-icon-button">
                        <svg class="settings-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                            <path fill-rule="evenodd" d="M3.792 2.938A49.069 49.069 0 0112 5.375c2.73 0 5.413.407 8.08.914a.75.75 0 01.57.842V19.08c-.01.12-.036.237-.077.35l-2.544 6.78a1.5 1.5 0 01-1.265.91c-.487.054-.978.125-1.47.214a49.027 49.027 0 01-11.082 0c-.492-.089-.983-.16-1.47-.214a1.5 1.5 0 01-1.265-.91L2.247 19.43a.75.75 0 01-.077-.35V9.124a.75.75 0 01.57-.842c2.667-.507 5.35-.914 8.08-.914zM12 11.25a1.5 1.5 0 100 3 1.5 1.5 0 000-3z" clip-rule="evenodd" />
                        </svg>
                    </button>
                    <span class="icon-button-tooltip">데이터 관리</span>
                </div>
            </div>
        </div>

        <div class="main-content-panels">
            <!-- Control Panel -->
            <div class="control-panel">
                <h2 class="text-2xl font-bold mb-6 text-gray-800">자리 배치 설정</h2>

                <div class="mb-4">
                    <label for="rows" class="block text-sm font-medium text-gray-700 mb-1">행 수 (Row Count)</label>
                    <input type="number" id="rows" value="4" min="1" class="w-full">
                </div>

                <div class="mb-6">
                    <label for="cols" class="block text-sm font-medium text-gray-700 mb-1">열 수 (Column Count)</label>
                    <input type="number" id="cols" value="5" min="1" class="w-full">
                </div>

                <button onclick="generateLayout()" class="w-full mb-6">
                    자리 배치 생성
                </button>

                <div class="mb-6">
                    <h3 class="text-lg font-medium text-gray-700 mb-2">학생 목록</h3>
                    <div id="studentListContainer" class="mb-4 border p-2 rounded-lg bg-white overflow-y-auto max-h-64">
                        <!-- Student input rows will be added here dynamically -->
                    </div>
                    <button onclick="addStudentRow()" class="w-full btn-add-student">
                        + 학생 추가
                    </button>
                </div>

                <button onclick="shuffleSeats()" class="w-full mb-3">
                    자리 바꾸기
                </button>
                <button onclick="resetApp()" class="w-full btn-reset">
                    모든 설정 및 배치 초기화
                </button>
            </div>

            <!-- Classroom Layout Visualization -->
            <div id="classroomLayoutContainer" class="classroom-layout-container">
                <div class="classroom-layout-header">
                    <h2 class="text-2xl font-bold mb-4 text-gray-800">교실 배치도</h2>
                </div>
                
                <div id="classroomLayout" class="classroom-layout">
                    <!-- Desks will be dynamically generated here -->
                </div>
                <p id="layoutMessage" class="mt-4 text-sm text-gray-600"></p>
                <!-- Desk Options Overlay -->
                <div id="deskOptionsOverlay" class="desk-options-overlay hidden">
                    <button data-option-type="random" class="btn-random-option">랜덤 자리</button>
                    <button data-option-type="male" class="btn-male-option">남학생 자리</button>
                    <button data-option-type="female" class="btn-female-option">여학생 자리</button>
                    <button data-option-type="delete" class="btn-delete-option">자리 삭제</button>
                </div>
            </div>

            <!-- Avoid Student Settings (hidden by default) -->
            <div id="avoidSettingsPanel" class="settings-panel hidden">
                <h2 class="text-2xl font-bold mb-4 text-gray-800">피해야 할 학생 설정</h2>
                <div id="avoidPairsContainer" class="mb-4">
                    <!-- Avoid pairs will be added here -->
                </div>
                <button onclick="addAvoidPair()" class="w-full btn-secondary">
                    + 피해야 할 학생 추가
                </button>
            </div>

            <!-- NEW: Snapshot History Panel (hidden by default) -->
            <div id="snapshotHistoryPanel" class="snapshot-history-panel hidden">
                <h2 class="text-2xl font-bold mb-4 text-gray-800">스냅샷 목록</h2>
                <div class="input-group mb-4">
                    <input type="text" id="snapshotNameInput" placeholder="스냅샷 이름 (선택 사항)" class="w-full">
                    <button onclick="saveSnapshot()" class="btn-secondary">저장</button>
                </div>
                <div id="savedSnapshotsList" class="saved-snapshots-list">
                    <p class="text-sm text-gray-500 text-center p-2">저장된 스냅샷이 없습니다.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Message Box for Alerts -->
    <div id="messageBox" class="message-box">
        <p id="messageText"></p>
        <button onclick="hideMessageBox()">확인</button>
    </div>

    <!-- Tutorial Message Box -->
    <div id="tutorialMessageBox" class="tutorial-message-box">
        <h3>학생 자리 배치 도구 사용법</h3>
        <ol>
            <li><strong>자리 배치 생성:</strong> '행 수'와 '열 수'를 입력하고 '자리 배치 생성' 버튼을 클릭하세요.</li>
            <li><strong>학생 목록 입력:</strong> '+ 학생 추가' 버튼으로 학생을 추가하고 이름과 성별을 설정합니다.</li>
            <li><strong>자리 유형 설정:</strong> 자리에 마우스를 올리면 나타나는 메뉴에서 '남학생', '여학생', '랜덤' 중 하나를 선택하여 자리 유형을 설정합니다.
                <ul>
                    <li><strong>노란색</strong>: 랜덤 자리 (모든 성별 가능)</li>
                    <li><strong>파란색</strong>: 남학생 자리 (남학생만 가능)</li>
                    <li><strong>분홍색</strong>: 여학생 자리 (여학생만 가능)</li>
                </ul>
            </li>
            <li><strong>자리 삭제 및 복구:</strong> 자리 메뉴에서 '자리 삭제'를 선택하거나, 자리에 마우스를 올렸을 때 나타나는 'X' 버튼을 눌러 자리를 삭제할 수 있습니다. 삭제된 자리는 '회색'으로 표시되며, '복구' 버튼으로 되돌릴 수 있습니다.</li>
            <li><strong>피해야 할 학생 설정:</strong> 오른쪽 상단의 톱니바퀴 버튼에 마우스를 올리면 '설정' 툴팁이 나타납니다. 클릭하여 '피해야 할 학생 설정' 패널을 열고, 함께 앉으면 안 되는 학생들을 지정합니다.</li>
            <li><strong>스냅샷 목록:</strong> 오른쪽 상단의 목록 아이콘에 마우스를 올리면 '데이터 관리' 툴팁이 나타납니다. 클릭하여 '스냅샷 목록' 패널을 열 수 있습니다.</li>
            <li><strong>스냅샷 저장:</strong> '스냅샷 목록' 패널에서 이름을 입력하고 '저장' 버튼을 클릭하여 현재 상태를 스냅샷으로 저장할 수 있습니다. 이름이 없으면 자동으로 날짜와 시간이 기록됩니다.</li>
            <li><strong>스냅샷 불러오기 및 삭제:</strong> '스냅샷 목록'에서 저장된 스냅샷들을 확인하고, '불러오기'나 '삭제' 버튼을 통해 관리할 수 있습니다.</li>
            <li><strong>자리 바꾸기:</strong> '자리 바꾸기' 버튼을 클릭하면 학생들이 모든 자리 유형과 피해야 할 학생 규칙을 고려하여 무작위로 배치됩니다.</li>
            <li><strong>자리 수동 변경:</strong> 학생들이 배치된 후, 학생이 있는 자리를 마우스로 끌어 다른 활성 자리로 옮기면 자리를 바꿀 수 있습니다. 이 기능은 피해야 할 학생 규칙과 자리 유형 선호에 영향을 받습니다.</li>
            <li><strong>초기화:</strong> '모든 설정 및 배치 초기화' 버튼으로 모든 데이터를 기본 상태로 되돌릴 수 있습니다.</li>
        </ol>
        <button onclick="hideTutorialMessageBox()">닫기</button>
    </div>

    <script>
        // DOM elements (changed to let and will be initialized in window.onload)
        let rowsInput;
        let colsInput;
        let studentListContainer;
        let classroomLayoutDiv;
        let layoutMessage;
        let messageBox;
        let messageText;
        let tutorialMessageBox;
        let avoidPairsContainer;
        let avoidSettingsPanel;
        let deskOptionsOverlay;
        let classroomLayoutContainer;
        let snapshotHistoryPanel; // New: Reference to the snapshot history panel
        let snapshotNameInput;
        let savedSnapshotsList;

        let rows = 4; // Default rows
        let cols = 5; // Default columns
        let placedStudents = []; // Array to hold {name, gender, originalIndex} of students placed on desks
        let studentData = []; // Array of {name, maleChecked, femaleChecked} from dynamic input rows
        let studentNames = []; // Derived from studentData: {name, gender} objects for shuffle logic
        let avoidRules = []; // Array of [student1, student2] pairs to avoid
        
        let deskGenderPreferences = []; // Stores 'random', 'male', 'female' for each desk
        let deskAvailability = []; // 'active' or 'inactive' for each desk (for deleted desks)
        
        let currentDeskForPreferenceChange = null; // Stores the index of the desk currently highlighted for preference change (green border)

        let dragSrcDeskIndex = null; // Index of the desk being dragged from
        let dragGhost = null; // Element for visual feedback during drag
        let dragStartX = 0;
        let dragStartY = 0;
        let isDragging = false;
        const dragThreshold = 5;

        let savedSnapshots = []; // Array to hold multiple saved states (snapshots)
        const MAX_SNAPSHOTS = 10; // Limit the number of saved snapshots

        let hoverTimeoutId = null; // Timeout for desk hover leave (to debounce closing overlay)
        let layoutMessageTimeoutId = null; // Timeout for layout messages


        // --- Local Storage Management ---

        /**
         * Saves the current working state of the application to a single local storage entry.
         * This state is automatically loaded on page refresh.
         */
        function saveData() {
            const data = {
                rows: rowsInput.value,
                cols: colsInput.value,
                studentData: studentData,
                placedStudents: placedStudents,
                avoidRules: avoidRules,
                deskGenderPreferences: deskGenderPreferences,
                deskAvailability: deskAvailability,
            };
            localStorage.setItem('studentSeatingAppCurrentState', JSON.stringify(data)); // Changed key for current state
        }

        /**
         * Loads the current working state from local storage.
         * This is called on initial page load.
         */
        function loadData() {
            const savedData = localStorage.getItem('studentSeatingAppCurrentState');
            if (savedData) {
                const data = JSON.parse(savedData);

                rowsInput.value = data.rows || 4;
                colsInput.value = data.cols || 5;
                rows = parseInt(rowsInput.value);
                cols = parseInt(colsInput.value);

                studentData = data.studentData || [];
                renderStudentList(); 

                placedStudents = data.placedStudents || [];
                avoidRules = data.avoidRules || [];
                deskGenderPreferences = data.deskGenderPreferences || [];
                deskAvailability = data.deskAvailability || [];
                
                generateLayout(false); // Generate layout without re-initializing preferences
                updateDeskVisuals();
                applyDeskGenderPreferencesVisuals();
                applyDeskAvailabilityVisuals();
                renderAvoidRules();

                updateLayoutMessage('이전 작업 상태가 로드되었습니다.', 2000); // Changed to layoutMessage

            } else {
                // If no current state saved, initialize with defaults and generate layout
                rows = parseInt(rowsInput.value);
                cols = parseInt(colsInput.value);
                generateLayout(); // Generate initial default layout
            }
        }

        /**
         * Saves the current application state as a named snapshot.
         */
        function saveSnapshot() {
            const snapshotName = snapshotNameInput.value.trim();
            const timestamp = new Date().toLocaleString('ko-KR', {
                year: 'numeric', month: '2-digit', day: '2-digit',
                hour: '2-digit', minute: '2-digit', second: '2-digit'
            });
            const uniqueId = Date.now().toString(); // Simple unique ID for now

            const currentAppState = {
                rows: rowsInput.value,
                cols: colsInput.value,
                studentData: studentData,
                placedStudents: placedStudents,
                avoidRules: avoidRules,
                deskGenderPreferences: deskGenderPreferences,
                deskAvailability: deskAvailability,
            };

            const newSnapshot = {
                id: uniqueId,
                name: snapshotName === '' ? `저장된 스냅샷 (${timestamp})` : snapshotName,
                timestamp: timestamp,
                data: currentAppState
            };

            let existingSnapshots = JSON.parse(localStorage.getItem('studentSeatingAppSnapshots') || '[]');
            
            // Limit to MAX_SNAPSHOTS
            if (existingSnapshots.length >= MAX_SNAPSHOTS) {
                existingSnapshots.shift(); // Remove the oldest snapshot
            }
            existingSnapshots.push(newSnapshot);
            localStorage.setItem('studentSeatingAppSnapshots', JSON.stringify(existingSnapshots));
            
            savedSnapshots = existingSnapshots; // Update global array
            renderSnapshotList();
            updateLayoutMessage('현재 상태가 스냅샷으로 저장되었습니다!', 1500); // Changed to layoutMessage
            snapshotNameInput.value = ''; // Clear input
        }

        /**
         * Loads a specific snapshot by its ID.
         * @param {string} snapshotId - The ID of the snapshot to load.
         */
        function loadSnapshot(snapshotId) {
            const snapshots = JSON.parse(localStorage.getItem('studentSeatingAppSnapshots') || '[]');
            const snapshotToLoad = snapshots.find(s => s.id === snapshotId);

            if (snapshotToLoad) {
                const data = snapshotToLoad.data;

                rowsInput.value = data.rows;
                colsInput.value = data.cols;
                rows = parseInt(rowsInput.value);
                cols = parseInt(colsInput.value);

                studentData = data.studentData;
                renderStudentList(); 

                placedStudents = data.placedStudents;
                avoidRules = data.avoidRules;
                deskGenderPreferences = data.deskGenderPreferences;
                deskAvailability = data.deskAvailability;
                
                generateLayout(false); // Generate layout with loaded dimensions, don't re-init
                updateDeskVisuals();
                applyDeskGenderPreferencesVisuals();
                applyDeskAvailabilityVisuals();
                renderAvoidRules();
                saveData(); // Save the loaded state as the new current working state

                updateLayoutMessage(`'${snapshotToLoad.name}' 스냅샷을 불러왔습니다.`, 2000); // Changed to layoutMessage
            } else {
                showMessageBox('선택된 스냅샷을 찾을 수 없습니다.', 2000); // This is a more critical error, keep as MessageBox
            }
        }

        /**
         * Deletes a specific snapshot by its ID.
         * @param {string} snapshotId - The ID of the snapshot to delete.
         */
        function deleteSnapshot(snapshotId) {
            let snapshots = JSON.parse(localStorage.getItem('studentSeatingAppSnapshots') || '[]');
            snapshots = snapshots.filter(s => s.id !== snapshotId);
            localStorage.setItem('studentSeatingAppSnapshots', JSON.stringify(snapshots));
            
            savedSnapshots = snapshots; // Update global array
            renderSnapshotList();
            updateLayoutMessage('스냅샷이 삭제되었습니다.', 1000); // Changed to layoutMessage
        }

        /**
         * Renders the list of saved snapshots in the data management modal.
         */
        function renderSnapshotList() {
            savedSnapshotsList.innerHTML = '';
            const snapshots = JSON.parse(localStorage.getItem('studentSeatingAppSnapshots') || '[]');
            
            if (snapshots.length === 0) {
                savedSnapshotsList.innerHTML = '<p class="text-sm text-gray-500 text-center p-2">저장된 스냅샷이 없습니다.</p>';
                return;
            }
            
            // Sort by timestamp descending (newest first)
            snapshots.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));


            snapshots.forEach(snapshot => {
                const itemDiv = document.createElement('div');
                itemDiv.classList.add('saved-snapshot-item');

                const detailsDiv = document.createElement('div');
                detailsDiv.classList.add('snapshot-details');
                detailsDiv.innerHTML = `
                    <span class="snapshot-name">${snapshot.name}</span>
                    <span class="snapshot-timestamp">${snapshot.timestamp}</span>
                `;

                const actionsDiv = document.createElement('div');
                actionsDiv.classList.add('snapshot-actions');

                const loadBtn = document.createElement('button');
                loadBtn.textContent = '불러오기';
                loadBtn.classList.add('btn-secondary', 'btn-load');
                loadBtn.onclick = () => loadSnapshot(snapshot.id);

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = '삭제';
                deleteBtn.classList.add('btn-secondary', 'btn-delete');
                deleteBtn.onclick = () => deleteSnapshot(snapshot.id);

                actionsDiv.appendChild(loadBtn);
                actionsDiv.appendChild(deleteBtn);

                itemDiv.appendChild(detailsDiv);
                itemDiv.appendChild(actionsDiv);
                savedSnapshotsList.appendChild(itemDiv);
            });
        }


        // --- UI Interactions ---

        /**
         * Displays a custom message box (for critical alerts).
         * @param {string} message - The message to display.
         * @param {number} [duration=0] - Duration in ms before hiding. 0 means manual close.
         */
        function showMessageBox(message, duration = 0) {
            messageText.textContent = message;
            messageBox.style.display = 'flex';
            if (duration > 0) {
                setTimeout(hideMessageBox, duration);
            }
        }

        /**
         * Hides the custom message box.
         */
        function hideMessageBox() {
            messageBox.style.display = 'none';
        }

        /**
         * Updates the text message below the classroom layout.
         * @param {string} message - The message to display.
         * @param {number} [duration=0] - Duration in ms before clearing. 0 means manual clear (or until next message).
         */
        function updateLayoutMessage(message, duration = 0) {
            layoutMessage.textContent = message;
            clearTimeout(layoutMessageTimeoutId);
            if (duration > 0) {
                layoutMessageTimeoutId = setTimeout(() => {
                    layoutMessage.textContent = ''; // Clear message after duration
                }, duration);
            }
        }


        /**
         * Shows the tutorial message box.
         */
        function showTutorialMessageBox() {
            tutorialMessageBox.style.display = 'flex';
        }

        /**
         * Hides the tutorial message box.
         */
        function hideTutorialMessageBox() {
            tutorialMessageBox.style.display = 'none';
        }
        
        /**
         * Toggles the visibility of the avoid student settings panel.
         */
        function toggleAvoidSettings() {
            // If the other panel is open, close it
            if (!snapshotHistoryPanel.classList.contains('hidden')) {
                snapshotHistoryPanel.classList.add('hidden');
            }
            avoidSettingsPanel.classList.toggle('hidden');
            saveData();
        }

        /**
         * Toggles the visibility of the snapshot history panel.
         */
        function toggleSnapshotHistoryPanel() {
            renderSnapshotList(); // Refresh list whenever it's toggled open
            // If the other panel is open, close it
            if (!avoidSettingsPanel.classList.contains('hidden')) {
                avoidSettingsPanel.classList.add('hidden');
            }
            snapshotHistoryPanel.classList.toggle('hidden');
            saveData();
        }


        /**
         * Clears the preference focus highlight (green border) from all desks.
         * Also hides the desk options overlay.
         */
        function clearPreferenceFocus() {
            const focusedDesk = classroomLayoutDiv.querySelector('.preference-focused');
            if (focusedDesk) {
                focusedDesk.classList.remove('preference-focused');
            }
            currentDeskForPreferenceChange = null;
            hideDeskOptionsOverlay(); // Hide overlay when focus is cleared
        }

        /**
         * Shows the desk options overlay positioned relative to the clicked desk.
         * @param {HTMLElement} deskElement - The desk element to position the overlay next to.
         */
        function showDeskOptionsOverlay(deskElement) {
            const deskRect = deskElement.getBoundingClientRect(); // Desk position relative to viewport
            const layoutContainerRect = classroomLayoutContainer.getBoundingClientRect(); // Layout container position relative to viewport
            const classroomLayoutScrollLeft = classroomLayoutDiv.scrollLeft; // Actual horizontal scroll of the grid
            const classroomLayoutScrollTop = classroomLayoutDiv.scrollTop; // Actual vertical scroll of the grid

            // Calculate position relative to classroomLayoutContainer's top-left corner
            const topOffset = deskRect.top - layoutContainerRect.top + classroomLayoutScrollTop;
            const leftOffset = deskRect.left - layoutContainerRect.left + classroomLayoutScrollLeft;

            // Position vertically centered with the desk
            deskOptionsOverlay.style.top = `${topOffset + (deskElement.offsetHeight / 2) - (deskOptionsOverlay.offsetHeight / 2)}px`;
            
            // Default position: to the right of the desk, with 5px padding
            let desiredLeft = leftOffset + deskElement.offsetWidth + 5; 

            // Check if positioning to the right goes off the right edge of the *classroomLayoutContainer*
            // We use layoutContainerRect.width for the visible width of the container.
            if (desiredLeft + deskOptionsOverlay.offsetWidth > classroomLayoutContainer.offsetWidth) {
                // If it goes off, position to the left of the desk instead
                desiredLeft = leftOffset - deskOptionsOverlay.offsetWidth - 5; // 5px padding from desk left
                // Ensure it doesn't go off the left edge of the container
                if (desiredLeft < 0) {
                    desiredLeft = 0; // Stick to the left edge if no other option
                }
            }
            deskOptionsOverlay.style.left = `${desiredLeft}px`;

            deskOptionsOverlay.classList.remove('hidden');
        }

        /**
         * Hides the desk options overlay.
         */
        function hideDeskOptionsOverlay() {
            deskOptionsOverlay.classList.add('hidden');
        }

        /**
         * Applies the selected mode to the 'currentDeskForPreferenceChange'.
         * This function is triggered by buttons in the overlay.
         * @param {string} mode - 'random', 'male', 'female', 'delete'.
         */
        function applyDeskTypeFromOverlay(mode) {
            if (currentDeskForPreferenceChange === null) {
                // This case should ideally not happen with hover, but good for robustness
                return;
            }

            if (mode === 'delete') {
                removeDesk(currentDeskForPreferenceChange);
                updateLayoutMessage(`${currentDeskForPreferenceChange + 1}번 자리가 삭제되었습니다.`, 1500); // Changed to layoutMessage
            } else {
                deskGenderPreferences[currentDeskForPreferenceChange] = mode;
                applyDeskGenderPreferencesVisuals(); 
                updateLayoutMessage(`${currentDeskForPreferenceChange + 1}번 자리 유형이 '${mode === 'random' ? '랜덤' : mode === 'male' ? '남학생' : '여학생'}'으로 설정되었습니다.`, 1500); // Changed to layoutMessage
            }

            clearPreferenceFocus(); // Clear the green highlight and hide overlay
            saveData(); // Save updated preferences/availability
        }

        /**
         * Sets up event listeners for the desk options overlay buttons.
         */
        function initDeskOptionsOverlayButtons() {
            deskOptionsOverlay.querySelectorAll('button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const optionType = e.target.dataset.optionType;
                    if (currentDeskForPreferenceChange !== null) {
                        applyDeskTypeFromOverlay(optionType);
                    }
                    e.stopPropagation(); // Prevent document click from immediately closing it after selection
                });
            });
        }


        // --- Student Data & Layout Functions ---

        /**
         * Renders the dynamic student input list from studentData.
         */
        function renderStudentList() {
            studentListContainer.innerHTML = '';
            studentData.forEach((student, index) => {
                const div = document.createElement('div');
                div.classList.add('student-list-item');
                div.dataset.index = index;

                const nameInput = document.createElement('input');
                nameInput.type = 'text';
                nameInput.placeholder = '이름';
                nameInput.value = student.name;
                nameInput.addEventListener('input', (e) => {
                    studentData[index].name = e.target.value.trim();
                    parseStudentNames(); // Re-parse and save on name change
                });

                const genderGroup = document.createElement('div');
                genderGroup.classList.add('gender-checkbox-group');

                const maleLabel = document.createElement('label');
                maleLabel.innerHTML = `<input type="checkbox" data-gender-type="male" ${student.maleChecked ? 'checked' : ''}> 남`;
                maleLabel.querySelector('input').addEventListener('change', (e) => {
                    studentData[index].maleChecked = e.target.checked;
                    if (e.target.checked) { // Only uncheck female if male is now checked
                        studentData[index].femaleChecked = false;
                        maleLabel.parentElement.querySelector('input[data-gender-type="female"]').checked = false;
                    }
                    parseStudentNames();
                });

                const femaleLabel = document.createElement('label');
                femaleLabel.innerHTML = `<input type="checkbox" data-gender-type="female" ${student.femaleChecked ? 'checked' : ''}> 여`;
                femaleLabel.querySelector('input').addEventListener('change', (e) => {
                    studentData[index].femaleChecked = e.target.checked;
                    if (e.target.checked) { // Only uncheck male if female is now checked
                        studentData[index].maleChecked = false;
                        femaleLabel.parentElement.querySelector('input[data-gender-type="male"]').checked = false;
                    }
                    parseStudentNames();
                });

                genderGroup.appendChild(maleLabel);
                genderGroup.appendChild(femaleLabel);

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = '삭제';
                deleteBtn.classList.add('btn-delete-student');
                deleteBtn.onclick = () => removeStudentRow(index);

                div.appendChild(nameInput);
                div.appendChild(genderGroup);
                div.appendChild(deleteBtn);
                studentListContainer.appendChild(div);
            });
            saveData();
        }

        /**
         * Adds a new empty row for student input.
         */
        function addStudentRow() {
            studentData.push({ name: '', maleChecked: false, femaleChecked: false });
            renderStudentList();
        }

        /**
         * Removes a student row by index.
         * @param {number} index - The index of the student row to remove.
         */
        function removeStudentRow(index) {
            studentData.splice(index, 1);
            renderStudentList();
            parseStudentNames(); // Re-parse after removal
        }


        /**
         * Parses student names from the dynamic input rows into an array of objects with name and gender.
         * Also updates the placedStudents array to reflect changes in studentData (gender or removal).
         * Gender is determined by explicit checkboxes.
         */
        function parseStudentNames() {
            studentNames = studentData.map(student => {
                let assignedGender = '무'; // Default unknown
                if (student.name.trim() === '') return null; // Filter out empty names immediately

                if (student.maleChecked && !student.femaleChecked) {
                    assignedGender = '남';
                } else if (student.femaleChecked && !student.maleChecked) {
                    assignedGender = '여';
                }
                return { name: student.name.trim(), gender: assignedGender };
            }).filter(student => student !== null); // Filter out empty names that are now null

            // Update placedStudents based on changes in studentNames
            // Create a map for quick lookup of current students
            const currentStudentMap = new Map(studentNames.map(s => [s.name, s]));

            for (let i = 0; i < placedStudents.length; i++) {
                const placed = placedStudents[i];
                if (placed) {
                    const updatedStudentInfo = currentStudentMap.get(placed.name);

                    if (updatedStudentInfo && updatedStudentInfo.gender === placed.gender) {
                        // Student exists and gender hasn't changed, keep as is
                    } else if (updatedStudentInfo && updatedStudentInfo.gender !== placed.gender) {
                        // Student exists but gender has changed, update it
                        placedStudents[i].gender = updatedStudentInfo.gender;
                    } else {
                        // Student no longer exists in studentNames, or is a duplicate
                        placedStudents[i] = null;
                    }
                }
            }
            
            updateDeskVisuals(); // Refresh visuals after updating placedStudents
            saveData(); // Save updated student names and placedStudents
        }


        /**
         * Generates the classroom layout grid based on rows and cols.
         * @param {boolean} [initializePreferences=true] - If true, initializes desk preferences to random and availability to active.
         */
        function generateLayout(initializePreferences = true) {
            rows = parseInt(rowsInput.value);
            cols = parseInt(colsInput.value);

            if (isNaN(rows) || isNaN(cols) || rows <= 0 || cols <= 0) {
                showMessageBox('유효한 행 수와 열 수를 입력해주세요.');
                return;
            }

            classroomLayoutDiv.innerHTML = '';
            classroomLayoutDiv.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            updateLayoutMessage(`${rows}행 ${cols}열의 자리 배치도가 생성되었습니다.`, 2000); // Changed to layoutMessage

            const totalDesks = rows * cols;
            // Only reset placedStudents and preferences/availability if generating a completely new layout
            if (initializePreferences) {
                placedStudents = Array(totalDesks).fill(null); // Reset placed students array
                deskGenderPreferences = Array(totalDesks).fill('random'); // Reset desk gender preferences to random
                deskAvailability = Array(totalDesks).fill('active'); // All desks are active by default
            } else {
                 // Adjust array sizes if layout changes (e.g., rows/cols changed) but keep existing data where possible
                if (placedStudents.length !== totalDesks) {
                    const newPlacedStudents = Array(totalDesks).fill(null);
                    for (let i = 0; i < Math.min(placedStudents.length, totalDesks); i++) {
                        newPlacedStudents[i] = placedStudents[i];
                    }
                    placedStudents = newPlacedStudents;
                }
                if (deskGenderPreferences.length !== totalDesks) {
                    const newDeskPreferences = Array(totalDesks).fill('random');
                    for (let i = 0; i < Math.min(deskGenderPreferences.length, totalDesks); i++) {
                        newDeskPreferences[i] = deskGenderPreferences[i];
                    }
                    deskGenderPreferences = newDeskPreferences;
                }
                if (deskAvailability.length !== totalDesks) {
                    const newDeskAvailability = Array(totalDesks).fill('active');
                    for (let i = 0; i < Math.min(deskAvailability.length, totalDesks); i++) {
                        newDeskAvailability[i] = deskAvailability[i];
                    }
                    deskAvailability = newDeskAvailability;
                }
            }


            for (let i = 0; i < totalDesks; i++) {
                const desk = document.createElement('div');
                desk.classList.add('desk');
                desk.dataset.index = i;
                desk.style.position = 'relative'; // For desk number positioning

                // Inner content for student name/gender
                const studentContentDiv = document.createElement('div');
                studentContentDiv.classList.add('desk-content');
                studentContentDiv.innerHTML = `<span class="desk-number">${i + 1}</span>`; // Always show desk number
                desk.appendChild(studentContentDiv);

                // Delete button (X to remove, Restore to restore)
                const deleteBtn = document.createElement('button');
                deleteBtn.classList.add('desk-delete-btn');
                // The text and onclick will be set by applyDeskAvailabilityVisuals
                desk.appendChild(deleteBtn);

                // Change: Use mouseenter/mouseleave for overlay
                desk.addEventListener('mouseenter', handleDeskHoverEnter);
                desk.addEventListener('mouseleave', handleDeskHoverLeave);
                desk.addEventListener('mousedown', handleMouseDown); // Keep mousedown for drag

                classroomLayoutDiv.appendChild(desk);
            }
            applyDeskGenderPreferencesVisuals(); // Apply initial/loaded gender type colors
            applyDeskAvailabilityVisuals(); // Apply initial/loaded availability visuals
            updateDeskVisuals(); // Set initial occupied/empty states
            saveData(); // Save layout and selection state
        }

        /**
         * Resets all app data to its initial default state.
         */
        function resetApp() {
            rowsInput.value = 4;
            colsInput.value = 5;
            studentData = [];
            addStudentRow(); // Add one empty student row by default
            avoidRules = [];
            renderAvoidRules();

            // Reset layout and all desk-related data
            generateLayout(true); 

            updateLayoutMessage('모든 설정 및 배치가 초기화되었습니다.', 2000); // Changed to layoutMessage
            saveData();
        }

        /**
         * Applies the desk gender preference classes to desk elements.
         */
        function applyDeskGenderPreferencesVisuals() {
            const desks = classroomLayoutDiv.children;
            for (let i = 0; i < desks.length; i++) {
                const desk = desks[i];
                // Remove existing desk-type classes first to prevent accumulation
                desk.classList.remove('desk-type-random', 'desk-type-male', 'desk-type-female');
                // Add the current preference class, defaulting to 'random' if not set
                desk.classList.add(`desk-type-${deskGenderPreferences[i] || 'random'}`); 
            }
        }

        /**
         * Applies the desk availability classes (e.g., 'inactive') to desk elements.
         */
        function applyDeskAvailabilityVisuals() {
            const desks = classroomLayoutDiv.children;
            for (let i = 0; i < desks.length; i++) {
                const desk = desks[i];
                if (deskAvailability[i] === 'inactive') {
                    desk.classList.add('inactive');
                    // Ensure delete button is always there but hidden by CSS, not removed
                    const deleteBtn = desk.querySelector('.desk-delete-btn');
                    if(deleteBtn) {
                        deleteBtn.textContent = '복구'; // Change text to 'restore'
                        deleteBtn.onclick = (event) => { // Change function to restore
                            event.stopPropagation();
                            restoreDesk(i);
                        };
                    }
                } else {
                    desk.classList.remove('inactive');
                    const deleteBtn = desk.querySelector('.desk-delete-btn');
                    if(deleteBtn) {
                        deleteBtn.textContent = 'X'; // Change text back to 'X'
                        deleteBtn.onclick = (event) => { // Change function back to remove
                            event.stopPropagation();
                            removeDesk(i);
                        };
                    }
                }
            }
        }

        /**
         * Updates the visual representation of desks with student names and gender.
         * Also updates desk classes (occupied/empty) and cursor styles based on actual student gender.
         */
        function updateDeskVisuals() {
            const desks = classroomLayoutDiv.children;
            for (let i = 0; i < desks.length; i++) {
                const desk = desks[i];
                const deskContentDiv = desk.querySelector('.desk-content'); // Get the content div
                if (!deskContentDiv) continue; // Should not happen

                // Clear existing student info (excluding desk number)
                deskContentDiv.querySelectorAll('.student-name, .student-gender').forEach(el => el.remove());
                desk.classList.remove('occupied', 'empty', 'student-gender-male', 'student-gender-female', 'student-gender-unknown');
                desk.style.cursor = 'default';

                const student = placedStudents[i];
                if (student && deskAvailability[i] === 'active') { // Only display student if desk is active
                    const nameSpan = document.createElement('span');
                    nameSpan.classList.add('student-name');
                    nameSpan.textContent = student.name;
                    deskContentDiv.appendChild(nameSpan);

                    if (student.gender && student.gender !== '무') {
                        const genderSpan = document.createElement('span');
                        genderSpan.classList.add('student-gender');
                        genderSpan.textContent = `(${student.gender})`;
                        deskContentDiv.appendChild(genderSpan);
                    }
                    desk.classList.add('occupied');
                    desk.style.cursor = 'grab';

                    // Add class based on actual student's gender for specific occupied coloring
                    if (student.gender === '남') {
                        desk.classList.add('student-gender-male');
                    } else if (student.gender === '여') {
                        desk.classList.add('student-gender-female');
                    } else {
                        desk.classList.add('student-gender-unknown');
                    }
                } else if (deskAvailability[i] === 'active') { // If active but empty
                    desk.classList.add('empty');
                    desk.style.cursor = 'pointer';
                }
                // If inactive, it will be handled by applyDeskAvailabilityVisuals
            }
        }

        /**
         * Removes (deactivates) a desk from the layout.
         * @param {number} index - The index of the desk to remove.
         */
        function removeDesk(index) {
            if (deskAvailability[index] === 'inactive') return; // Already inactive

            deskAvailability[index] = 'inactive';
            placedStudents[index] = null; // Remove any student on this desk
            clearPreferenceFocus(); // Clear green focus if this desk was focused

            applyDeskAvailabilityVisuals(); // Update visual to inactive
            updateDeskVisuals(); // Remove student visual

            updateLayoutMessage(`${index + 1}번 자리가 삭제(비활성화)되었습니다.`, 1500); // Changed to layoutMessage
            saveData();
        }

        /**
         * Restores (activates) a previously removed desk.
         * @param {number} index - The index of the desk to restore.
         */
        function restoreDesk(index) {
            if (deskAvailability[index] === 'active') return; // Already active

            deskAvailability[index] = 'active';
            
            applyDeskAvailabilityVisuals(); // Update visual to active
            updateDeskVisuals(); // Update to empty state

            updateLayoutMessage(`${index + 1}번 자리가 복구(활성화)되었습니다.`, 1500); // Changed to layoutMessage
            saveData();
        }


        /**
         * Shuffles students and assigns them to desks based on gender preferences and avoid rules.
         * This version attempts to place students systematically with preference, then fills remaining.
         */
        function shuffleSeats() {
            parseStudentNames(); // Make sure studentNames is up-to-date
            if (studentNames.length === 0) {
                showMessageBox('학생 목록을 먼저 입력해주세요.', 1500);
                return;
            }

            const totalDesks = rows * cols;
            const allActiveDesksIndices = []; // Indices of all desks that are 'active' (not deleted)
            for (let i = 0; i < totalDesks; i++) {
                if (deskAvailability[i] === 'active') {
                    allActiveDesksIndices.push(i);
                }
            }

            if (studentNames.length > allActiveDesksIndices.length) {
                showMessageBox(`학생 수(${studentNames.length})가 배치할 수 있는 활성 자리 수(${allActiveDesksIndices.length})보다 많습니다. 학생 수를 줄이거나 자리를 늘려주세요.`, 5000);
                return;
            }

            let shuffleSuccessful = false;
            let currentAttempt = 0;
            const maxAttempts = 5000; // Increased attempts for more robustness

            while (currentAttempt < maxAttempts && !shuffleSuccessful) {
                let trialPlacement = Array(totalDesks).fill(null);
                // Initialize inactive desks in trial placement
                for (let i = 0; i < totalDesks; i++) {
                    if (deskAvailability[i] === 'inactive') {
                        trialPlacement[i] = null;
                    }
                }

                let currentStudentsInPool = shuffleArray([...studentNames]); // All students, shuffled for this attempt
                
                // Helper function to try placing a student and update currentStudentsInPool
                const tryPlaceAndRemove = (studentToPlace, deskIndex, currentTrialPlacement, pool) => {
                    currentTrialPlacement[deskIndex] = studentToPlace;
                    if (checkAllAvoidRules(studentToPlace.name, deskIndex, currentTrialPlacement, rows, cols, avoidRules)) {
                        // Successfully placed, remove from the current working pool
                        const studentIndexInPool = pool.findIndex(s => s.name === studentToPlace.name && s.gender === studentToPlace.gender);
                        if (studentIndexInPool !== -1) {
                            pool.splice(studentIndexInPool, 1);
                        }
                        return true;
                    }
                    currentTrialPlacement[deskIndex] = null; // Backtrack
                    return false;
                };

                // Phase 1: STRICTLY place gendered students into their matching preferred desks
                // Sort desks by preference to ensure a consistent attempt order for strict desks
                const malePreferredDesksIndices = shuffleArray(allActiveDesksIndices.filter(idx => deskGenderPreferences[idx] === 'male'));
                for (const deskIndex of malePreferredDesksIndices) {
                    if (trialPlacement[deskIndex] !== null) continue; // Already filled (shouldn't happen in P1 if logic is right)
                    if (currentStudentsInPool.length === 0) break;

                    const eligibleMales = currentStudentsInPool.filter(s => s.gender === '남'); // Strictly only male students
                    if (eligibleMales.length === 0) continue; // No males left for this strict desk

                    let studentPlaced = false;
                    for (const student of shuffleArray(eligibleMales)) { // Shuffle eligible males for randomness
                        if (tryPlaceAndRemove(student, deskIndex, trialPlacement, currentStudentsInPool)) {
                            studentPlaced = true;
                            break;
                        }
                    }
                    // If not placed, this strict male desk remains empty for now for strict male
                }

                const femalePreferredDesksIndices = shuffleArray(allActiveDesksIndices.filter(idx => deskGenderPreferences[idx] === 'female'));
                for (const deskIndex of femalePreferredDesksIndices) {
                    if (trialPlacement[deskIndex] !== null) continue; // Already filled
                    if (currentStudentsInPool.length === 0) break;

                    const eligibleFemales = currentStudentsInPool.filter(s => s.gender === '여'); // Strictly only female students
                    if (eligibleFemales.length === 0) continue; // No females left for this strict desk

                    let studentPlaced = false;
                    for (const student of shuffleArray(eligibleFemales)) { // Shuffle eligible females for randomness
                        if (tryPlaceAndRemove(student, deskIndex, trialPlacement, currentStudentsInPool)) {
                            studentPlaced = true;
                            break;
                        }
                    }
                    // If not placed, this strict female desk remains empty for now for strict female
                }

                // Phase 2: Place remaining students into random-preferred desks and then fill any remaining gendered desks (if possible with matching or '무' but NOT opposite gender)
                const randomDesksIndices = shuffleArray(allActiveDesksIndices.filter(idx => deskGenderPreferences[idx] === 'random'));
                const unfilledMaleDesks = shuffleArray(malePreferredDesksIndices.filter(idx => trialPlacement[idx] === null)); // Male desks still empty from Phase 1
                const unfilledFemaleDesks = shuffleArray(femalePreferredDesksIndices.filter(idx => trialPlacement[idx] === null)); // Female desks still empty from Phase 1

                // Combine all remaining empty active desks in a shuffled order
                const allRemainingEmptyActiveDesks = shuffleArray([
                    ...randomDesksIndices.filter(idx => trialPlacement[idx] === null), // Random desks that are empty
                    ...unfilledMaleDesks,
                    ...unfilledFemaleDesks
                ]);

                for (const deskIndex of allRemainingEmptyActiveDesks) {
                    if (currentStudentsInPool.length === 0) break; // All students placed

                    const deskType = deskGenderPreferences[deskIndex];

                    const eligibleStudentsForThisDesk = currentStudentsInPool.filter(student => {
                        if (deskType === 'random') {
                            return true; // Any student can go to a random desk
                        } else if (deskType === 'male') {
                            // Male-preferred desk: allow '남' or '무'
                            return student.gender === '남' || student.gender === '무';
                        } else if (deskType === 'female') {
                            // Female-preferred desk: allow '여' or '무'
                            return student.gender === '여' || student.gender === '무';
                        }
                        return false; // Should not reach here for active desks
                    });
                    
                    // Attempt to place an eligible student
                    for (const student of shuffleArray(eligibleStudentsForThisDesk)) {
                        if (tryPlaceAndRemove(student, deskIndex, trialPlacement, currentStudentsInPool)) {
                            break; // Student placed, move to next desk
                        }
                    }
                }

                // Check if all original students were placed
                if (currentStudentsInPool.length === 0) { // If the pool is empty, all students were placed
                    placedStudents = trialPlacement;
                    shuffleSuccessful = true;
                }
                currentAttempt++;
            }

            // --- Finalize and update UI ---
            if (shuffleSuccessful) {
                updateLayoutMessage('자리 배치가 완료되었습니다!', 1500); // Changed to layoutMessage
            } else {
                // If shuffle failed, clear all students from active desks to reflect no valid placement
                for(let i = 0; i < totalDesks; i++) {
                    if (deskAvailability[i] === 'active') { // Clear only active desks
                        placedStudents[i] = null;
                    }
                }
                showMessageBox('모든 규칙을 만족하는 자리 배치를 찾을 수 없습니다. 피해야 할 학생 규칙을 줄이거나 학생 목록/자리 유형을 조정해주세요.', 5000); // Critical message, keep as MessageBox
            }

            updateDeskVisuals(); // Update UI with the final placement (or cleared state)
            saveData(); // Save the new placement state
        }


        /**
         * Shuffles an array randomly using Fisher-Yates algorithm.
         * @param {Array} array - The array to shuffle.
         * @returns {Array} The shuffled array.
         */
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        /**
         * Checks if placing a student at a specific desk violates any "avoid" rules.
         * @param {string} studentName - The name of the student to place.
         * @param {number} deskIndex - The index of the desk where the student is to be placed.
         * @param {Array} currentPlacement - The current state of placed students (including temporary placements).
         * @param {number} totalRows - Total rows in the layout.
         * @param {number} totalCols - Total columns in the layout.
         * @param {Array} rules - The array of avoid rules (e.g., [['김철수', '이영희']]).
         * @returns {boolean} True if no rules are violated, false otherwise.
         */
        function checkAllAvoidRules(studentName, deskIndex, currentPlacement, totalRows, totalCols, rules) {
            const row = Math.floor(deskIndex / totalCols);
            const col = deskIndex % totalCols;

            for (const rule of rules) {
                const avoidStudent1 = rule[0];
                const avoidStudent2 = rule[1];

                // Check if the current student is part of this avoid rule
                const isCurrentStudentRulePart = (studentName === avoidStudent1 || studentName === avoidStudent2);
                if (!isCurrentStudentRulePart) continue; // If the student being checked is not part of this rule, skip.

                // Determine the "partner" student in this rule
                const partnerStudentName = (studentName === avoidStudent1) ? avoidStudent2 : avoidStudent1;

                // Check surrounding desks (Up, Down, Left, Right)
                const neighbors = [
                    [row - 1, col], // Up
                    [row + 1, col], // Down
                    [row, col - 1], // Left
                    [row, col + 1]  // Right
                ];

                for (const [nRow, nCol] of neighbors) {
                    // Check if neighbor is within classroom bounds
                    if (nRow >= 0 && nRow < totalRows && nCol >= 0 && nCol < totalCols) {
                        const neighborDeskIndex = nRow * totalCols + nCol;
                        const neighborStudent = currentPlacement[neighborDeskIndex]; // Get student at neighbor desk

                        // If a neighbor student exists and is the "partner" student from the avoid rule
                        if (neighborStudent && neighborStudent.name === partnerStudentName) {
                            return false; // Rule violated
                        }
                    }
                }
            }
            return true; // No rules violated
        }


        // --- Avoid Rules Management ---

        /**
         * Renders the current avoid rules in the settings panel.
         */
        function renderAvoidRules() {
            avoidPairsContainer.innerHTML = '';
            if (avoidRules.length === 0) {
                avoidPairsContainer.innerHTML = '<p class="text-sm text-gray-500">피해야 할 학생 규칙이 없습니다.</p>';
            }
            avoidRules.forEach((pair, index) => {
                const div = document.createElement('div');
                div.classList.add('avoid-pair-item');
                div.dataset.index = index;

                const input1 = document.createElement('input');
                input1.type = 'text';
                input1.value = pair[0];
                input1.placeholder = '학생 이름 1';
                input1.classList.add('text-sm');
                input1.addEventListener('input', (e) => {
                    pair[0] = e.target.value.trim();
                    saveData();
                });

                const span = document.createElement('span');
                span.textContent = ' 과 ';
                span.classList.add('text-gray-700');

                const input2 = document.createElement('input');
                input2.type = 'text';
                input2.value = pair[1];
                input2.placeholder = '학생 이름 2';
                input2.classList.add('text-sm');
                input2.addEventListener('input', (e) => {
                    pair[1] = e.target.value.trim();
                    saveData();
                });

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = '삭제';
                deleteBtn.classList.add('btn-secondary', 'btn-delete-student'); // Added specific class for red delete button
                deleteBtn.onclick = () => removeAvoidPair(index);

                div.appendChild(input1);
                div.appendChild(span);
                div.appendChild(input2);
                div.appendChild(deleteBtn);
                avoidPairsContainer.appendChild(div);
            });
        }

        /**
         * Adds a new empty avoid rule pair.
         */
        function addAvoidPair() {
            avoidRules.push(['', '']);
            renderAvoidRules();
            saveData();
        }

        /**
         * Removes an avoid rule by its index.
         * @param {number} index - The index of the rule to remove.
         */
        function removeAvoidPair(index) {
            avoidRules.splice(index, 1);
            renderAvoidRules();
            saveData();
        }


        // --- Drag & Drop Handlers ---

        /**
         * Handles mouse down event on a desk. Initiates drag.
         * @param {MouseEvent} e
         */
        function handleMouseDown(e) {
            // Prevent drag if desk is inactive
            const deskElement = e.target.closest('.desk');
            const deskIndex = parseInt(deskElement.dataset.index);
            if (deskAvailability[deskIndex] === 'inactive') {
                e.preventDefault();
                return;
            }

            // Only allow drag from occupied desks or their children
            if (!e.target.classList.contains('occupied') && !e.target.closest('.occupied')) {
                return;
            }

            // Prevent drag if a desk is currently focused for preference change (green border)
            if (currentDeskForPreferenceChange !== null) {
                e.preventDefault();
                showMessageBox('자리 유형 설정 모드에서는 자리를 드래그할 수 없습니다. 모드를 해제하려면 빈 공간을 클릭하세요.', 3000);
                return;
            }

            // Clear any preference focus (green border) if starting a drag
            clearPreferenceFocus();


            // Existing drag initiation logic
            dragSrcDeskIndex = parseInt(deskElement.dataset.index);
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            isDragging = false; // Reset drag flag

            dragGhost = document.createElement('div');
            dragGhost.classList.add('drag-ghost');
            dragGhost.style.width = deskElement.offsetWidth + 'px';
            dragGhost.style.height = deskElement.offsetHeight + 'px';
            dragGhost.innerHTML = deskElement.innerHTML; // Copy content (name, gender, etc.)
            // Remove the delete button from the ghost to prevent accidental clicks
            const ghostDeleteBtn = dragGhost.querySelector('.desk-delete-btn');
            if(ghostDeleteBtn) ghostDeleteBtn.remove();

            document.body.appendChild(dragGhost);

            // Hide the original desk temporarily (visual feedback)
            deskElement.classList.add('dragging');

            document.addEventListener('mousemove', onDragging);
            document.addEventListener('mouseup', onMouseUpGlobal);
        }

        /**
         * Handles mouse move event during drag. Updates ghost position and drag-over class.
         * @param {MouseEvent} e
         */
        function onDragging(e) {
            // Check if movement exceeds threshold to confirm drag
            if (!isDragging && (Math.abs(e.clientX - dragStartX) > dragThreshold || Math.abs(e.clientY - dragStartY) > dragThreshold)) {
                isDragging = true;
            }

            if (dragGhost && isDragging) {
                dragGhost.style.left = e.clientX - dragGhost.offsetWidth / 2 + 'px';
                dragGhost.style.top = e.clientY - dragGhost.offsetHeight / 2 + 'px';

                // Remove drag-over from all desks
                document.querySelectorAll('.desk').forEach(desk => {
                    desk.classList.remove('drag-over');
                });

                // Find the desk element currently under the ghost
                const targetElement = document.elementFromPoint(e.clientX, e.clientY);
                const targetDesk = targetElement ? targetElement.closest('.desk') : null;

                // Apply drag-over only if it's an active desk and not the source desk
                if (targetDesk && targetDesk.dataset.index !== String(dragSrcDeskIndex) && 
                    deskAvailability[parseInt(targetDesk.dataset.index)] === 'active') {
                    targetDesk.classList.add('drag-over');
                }
            }
        }

        /**
         * Handles mouse up event globally. Ends drag operation.
         * @param {MouseEvent} e
         */
        function onMouseUpGlobal(e) {
            document.removeEventListener('mousemove', onDragging);
            document.removeEventListener('mouseup', onMouseUpGlobal);

            if (dragGhost) {
                dragGhost.remove();
                dragGhost = null;
            }

            // Restore opacity and remove dragging class from source desk
            const sourceDeskElement = document.querySelector(`.desk[data-index="${dragSrcDeskIndex}"]`);
            if (sourceDeskElement) {
                sourceDeskElement.classList.remove('dragging');
            }

            // Remove drag-over class from all desks
            document.querySelectorAll('.desk').forEach(desk => {
                desk.classList.remove('drag-over');
            });

            // If it was a drag operation (not just a click)
            if (isDragging) {
                const targetElement = document.elementFromPoint(e.clientX, e.clientY);
                const targetDeskElement = targetElement ? targetElement.closest('.desk') : null;
                if (targetDeskElement) {
                    const targetDeskIndex = parseInt(targetDeskElement.dataset.index);
                    // Perform drop only if the target is an active desk and not the source desk itself
                    if (deskAvailability[targetDeskIndex] === 'active' && targetDeskIndex !== dragSrcDeskIndex) {
                        drop(dragSrcDeskIndex, targetDeskIndex);
                    } else {
                        // If not a valid drop target, show message and revert
                        if (targetDeskIndex === dragSrcDeskIndex) {
                            updateLayoutMessage('동일한 자리에는 옮길 수 없습니다.', 1500); // Changed to layoutMessage
                        } else if (deskAvailability[targetDeskIndex] === 'inactive') {
                            updateLayoutMessage('삭제된 자리에는 학생을 옮길 수 없습니다.', 2000); // Changed to layoutMessage
                        }
                    }
                } else {
                    updateLayoutMessage('자리에 놓아야 합니다.', 1500); // Changed to layoutMessage
                }
            }
            dragSrcDeskIndex = null;
            isDragging = false; // Reset drag flag
        }


        /**
         * Handles mouseenter event on a desk. Shows preference focus and overlay.
         * @param {MouseEvent} e
         */
        function handleDeskHoverEnter(e) {
            clearTimeout(hoverTimeoutId); // Clear any pending hide
            if (isDragging) return; // Don't show overlay if dragging is active

            const deskElement = e.currentTarget;
            const deskIndex = parseInt(deskElement.dataset.index);

            if (deskAvailability[deskIndex] === 'inactive') return; // No overlay for inactive desks

            // If already showing for this desk, do nothing
            if (currentDeskForPreferenceChange === deskIndex) return;

            // If we're hovering over a new desk, clear old focus first
            if (currentDeskForPreferenceChange !== null) {
                clearPreferenceFocus();
            }

            deskElement.classList.add('preference-focused');
            currentDeskForPreferenceChange = deskIndex;
            showDeskOptionsOverlay(deskElement);
        }

        /**
         * Handles mouseleave event from a desk. Schedules hide of preference focus and overlay.
         * @param {MouseEvent} e
         */
        function handleDeskHoverLeave(e) {
            // If moving to the overlay itself, attach a listener to the overlay to keep it open
            if (e.relatedTarget && e.relatedTarget.closest('#deskOptionsOverlay') === deskOptionsOverlay) {
                deskOptionsOverlay.addEventListener('mouseleave', handleOverlayLeave);
                return;
            }

            // Otherwise, set a timeout to hide if not re-entering desk or moving to overlay
            hoverTimeoutId = setTimeout(() => {
                clearPreferenceFocus(); // Clear after a short delay
            }, 100); // Small delay to prevent accidental flicker
        }

        /**
         * Handles mouseleave event from the desk options overlay. Clears focus and hides.
         * @param {MouseEvent} e
         */
        function handleOverlayLeave(e) {
            // If moving back to a desk, or staying within the overlay
            if (e.relatedTarget && (e.relatedTarget.closest('.desk') || e.relatedTarget.closest('#deskOptionsOverlay') === deskOptionsOverlay)) {
                // Do nothing, a new hover enter will handle it or it stays in overlay
            } else {
                // Mouse left overlay to somewhere else, clear focus and hide
                clearPreferenceFocus();
            }
            deskOptionsOverlay.removeEventListener('mouseleave', handleOverlayLeave); // Clean up
        }

        /**
         * Handles general click event on a desk. This is distinct from hover logic.
         * This function should primarily be for *clicking* an option within the overlay, not triggering the overlay itself.
         * Original logic of `handleDeskClick` is now split between `handleDeskHoverEnter` for showing overlay and `click` on overlay buttons for actions.
         * I'm renaming the old `handleDeskClick` to `_handleDeskClickInternal` and ensuring it's not actually attached
         * to desk elements directly anymore, as hover is now the trigger for overlay.
         */
        function _handleDeskClickInternal(e) {
            // This function is no longer directly attached to desks for opening the overlay.
            // It remains here to show its previous content, but it should not be called by desk clicks.
            // Desk clicks are now primarily handled by mousedown (for drag) and hover (for overlay).
            console.log("Desk clicked (internal handler).");
            // Original `handleDeskClick` content would go here if needed for *actual* clicks on the desk for other purposes.
        }


        // Add a global click listener to hide panels if clicked outside
        document.addEventListener('click', (e) => {
            // Check if the click target is NOT a desk, NOT inside the desk options overlay, and NOT the tutorial or message box
            const isClickOutsidePanelsAndOverlays = !e.target.closest('#avoidSettingsPanel') &&
                                                    !e.target.closest('.settings-icon-button') && // Exclude setting icon button
                                                    !e.target.closest('#snapshotHistoryPanel') &&
                                                    !e.target.closest('.icon-button-container') && // Exclude snapshot icon button
                                                    !e.target.closest('.tutorial-message-box') &&
                                                    !e.target.closest('.message-box') &&
                                                    !e.target.closest('.desk-options-overlay') && // Exclude desk options overlay
                                                    !e.target.closest('.desk'); // Exclude desk itself (handled by hover/mousedown)
            
            if (isClickOutsidePanelsAndOverlays) {
                // Only hide panels, not desk-related overlays handled by hover
                if (!avoidSettingsPanel.classList.contains('hidden')) {
                    avoidSettingsPanel.classList.add('hidden');
                }
                if (!snapshotHistoryPanel.classList.contains('hidden')) {
                    snapshotHistoryPanel.classList.add('hidden');
                }
            }
        });


        /**
         * Performs the actual swap of students between two desks.
         * @param {number} sourceIndex - Index of the source desk.
         * @param {number} targetIndex - Index of the target desk.
         */
        function drop(sourceIndex, targetIndex) {
            const student1 = placedStudents[sourceIndex];
            const student2 = placedStudents[targetIndex];

            // Prevent drop if target is inactive
            if (deskAvailability[targetIndex] === 'inactive') {
                updateLayoutMessage('삭제된 자리에는 학생을 옮길 수 없습니다.', 2000); // Changed to layoutMessage
                return;
            }

            // Temporarily swap to check rules
            const tempPlacement = [...placedStudents];
            tempPlacement[sourceIndex] = student2;
            tempPlacement[targetIndex] = student1;

            let swapAllowed = true;
            let violationMessage = '';

            // Check avoid rules for student1 at targetIndex
            if (student1 && !checkAllAvoidRules(student1.name, targetIndex, tempPlacement, rows, cols, avoidRules)) {
                swapAllowed = false;
                violationMessage = `${student1.name}을(를) #${targetIndex + 1} 자리에 배치하면 피해야 할 학생 규칙에 위배됩니다.`;
            }
            // Check avoid rules for student2 at sourceIndex (only if student2 exists)
            if (swapAllowed && student2 && !checkAllAvoidRules(student2.name, sourceIndex, tempPlacement, rows, cols, avoidRules)) {
                swapAllowed = false;
                violationMessage = `${student2.name}을(를) #${sourceIndex + 1} 자리에 배치하면 피해야 할 학생 규칙에 위배됩니다.`;
            }

            // Check if dropped student's gender matches target desk's preference (if not 'random')
            const targetDeskPreference = deskGenderPreferences[targetIndex] || 'random';
            if (swapAllowed && student1 && targetDeskPreference !== 'random' && student1.gender !== '무' && student1.gender !== targetDeskPreference.charAt(0)) {
                if ((targetDeskPreference === 'male' && student1.gender === '여') ||
                    (targetDeskPreference === 'female' && student1.gender === '남')) {
                    updateLayoutMessage(`${student1.name}은(는) ${targetDeskPreference === 'male' ? '남학생' : '여학생'} 자리인 #${targetIndex + 1}에 적합하지 않습니다.`, 3000); // Changed to layoutMessage
                }
            }
             // Check if swapped-out student's gender matches source desk's preference (if not 'random')
             const sourceDeskPreference = deskGenderPreferences[sourceIndex] || 'random';
             if (swapAllowed && student2 && sourceDeskPreference !== 'random' && student2.gender !== '무' && student2.gender !== sourceDeskPreference.charAt(0)) {
                 if ((sourceDeskPreference === 'male' && student2.gender === '여') ||
                     (sourceDeskPreference === 'female' && student2.gender === '남')) {
                     updateLayoutMessage(`${student2.name}은(는) ${sourceDeskPreference === 'male' ? '남학생' : '여학생'} 자리인 #${sourceIndex + 1}에 적합하지 않습니다.`, 3000); // Changed to layoutMessage
                 }
             }


            if (swapAllowed) {
                placedStudents[sourceIndex] = student2;
                placedStudents[targetIndex] = student1;
                updateDeskVisuals();
                saveData(); // Save the new placement
                updateLayoutMessage('자리가 성공적으로 변경되었습니다!', 1000); // Changed to layoutMessage
            } else {
                showMessageBox(`자리 변경 불가: ${violationMessage}`, 3000); // Critical message, keep as MessageBox
            }
        }

        // --- Event Listeners for Input Changes (Auto-save) ---
        // These are global, so they can be set directly.
        // The elements themselves are accessed in window.onload and referenced by the global vars.
        
        // --- Initialize on Load ---
        window.onload = function() {
            // Assign DOM elements here to ensure they exist
            rowsInput = document.getElementById('rows');
            colsInput = document.getElementById('cols');
            studentListContainer = document.getElementById('studentListContainer');
            classroomLayoutDiv = document.getElementById('classroomLayout');
            layoutMessage = document.getElementById('layoutMessage');
            messageBox = document.getElementById('messageBox');
            messageText = document.getElementById('messageText');
            tutorialMessageBox = document.getElementById('tutorialMessageBox');
            avoidPairsContainer = document.getElementById('avoidPairsContainer');
            avoidSettingsPanel = document.getElementById('avoidSettingsPanel');
            deskOptionsOverlay = document.getElementById('deskOptionsOverlay');
            classroomLayoutContainer = document.getElementById('classroomLayoutContainer');
            snapshotHistoryPanel = document.getElementById('snapshotHistoryPanel'); // New: Reference to the snapshot history panel
            snapshotNameInput = document.getElementById('snapshotNameInput');
            savedSnapshotsList = document.getElementById('savedSnapshotsList');

            // Add event listeners that rely on initialized elements
            rowsInput.addEventListener('input', saveData);
            colsInput.addEventListener('input', saveData);

            initDeskOptionsOverlayButtons(); // Setup overlay button listeners
            loadData(); // Attempt to load data first
            if (studentData.length === 0) { // If no students loaded, add a default empty row
                addStudentRow();
            }
        };
    </script>
</body>
</html>
